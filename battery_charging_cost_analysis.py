#!/usr/bin/env python3
"""
Battery Charging Cost Analysis with Variable Durations
======================================================

Calculates NET profit after accounting for charging costs:
- Charge costs (buying electricity at low prices)
- Discharge revenue (selling at high prices)
- Round-trip efficiency losses (typically 85-90%)
- Net profit per cycle
- Optimal charge/discharge timing
- Duration sensitivity (0.5h, 1h, 1.5h, 2h, 4h)

Key Insights:
- Longer duration = more energy capacity = higher potential revenue
- But longer duration = slower response = may miss price spikes
- Trade-off: capacity vs agility

Usage:
    .venv/bin/python battery_charging_cost_analysis.py
"""

import os
import pandas as pd
import numpy as np
from google.cloud import bigquery
from datetime import datetime

# ==================== CONFIG ====================
PROJECT_ID = "inner-cinema-476211-u9"
DATASET_ID = "uk_energy_prod"
os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'inner-cinema-credentials.json'

# Battery efficiency (round-trip)
# Source: Li-ion BESS typically 85-90% efficient
ROUND_TRIP_EFFICIENCY = 0.87  # 87% typical for modern Li-ion

# Duration scenarios to analyze (hours)
DURATION_SCENARIOS = [0.5, 1.0, 1.5, 2.0, 4.0]

# CAPEX for different durations (Â£/kWh)
CAPEX_BY_DURATION = {
    0.5: 250,  # Higher $/kWh for shorter duration
    1.0: 220,
    1.5: 200,
    2.0: 200,
    4.0: 180,  # Lower $/kWh for longer duration (economies of scale)
}

# Analysis period
ANALYSIS_DAYS = 365

# Minimum price spread to justify cycling (Â£/MWh)
MIN_SPREAD_THRESHOLD = 5.0  # Don't cycle unless spread > Â£5/MWh


def get_battery_acceptance_data():
    """
    Load battery acceptance data with detailed charge/discharge actions
    """
    client = bigquery.Client(project=PROJECT_ID, location="US")
    
    # Load battery BMU list from CSV (generated by complete_vlp_battery_analysis.py)
    import glob
    battery_files = sorted(glob.glob('battery_bmus_complete_*.csv'), reverse=True)
    
    if not battery_files:
        print("âŒ No battery BMU file found. Run complete_vlp_battery_analysis.py first.")
        return pd.DataFrame()
    
    print(f"ğŸ“‚ Loading battery BMUs from: {battery_files[0]}")
    battery_bmus = pd.read_csv(battery_files[0])
    battery_list = battery_bmus['nationalGridBmUnit'].unique().tolist()
    print(f"âœ… Loaded {len(battery_list)} battery BMUs")
    
    # Create capacity map (use generationCapacity column)
    capacity_map = dict(zip(battery_bmus['nationalGridBmUnit'], battery_bmus['generationCapacity']))
    
    # Convert to SQL-safe list for WHERE IN clause
    battery_list_sql = "', '".join(battery_list[:150])  # Limit to 150 to avoid query size issues
    
    query = f"""
    WITH market_prices AS (
        -- Get settlement period prices
        SELECT 
            settlementDate,
            settlementPeriod,
            AVG(CASE WHEN price > 0 THEN price END) as avg_price_gbp_mwh,
            MAX(CASE WHEN price > 0 THEN price END) as max_price_gbp_mwh,
            MIN(CASE WHEN price > 0 THEN price END) as min_price_gbp_mwh
        FROM `{PROJECT_ID}.{DATASET_ID}.bmrs_mid`
        WHERE settlementDate >= DATE_SUB(CURRENT_DATE(), INTERVAL {ANALYSIS_DAYS} DAY)
        GROUP BY settlementDate, settlementPeriod
    ),
    battery_actions AS (
        -- Get actual accepted bid-offer dispatches
        SELECT 
            boalf.bmUnit,
            boalf.settlementDate,
            boalf.settlementPeriodFrom,
            boalf.levelFrom,
            boalf.levelTo,
            (boalf.levelTo - boalf.levelFrom) as mw_change,
            boalf.acceptanceNumber,
            boalf.acceptanceTime,
            prices.avg_price_gbp_mwh,
            prices.max_price_gbp_mwh,
            prices.min_price_gbp_mwh,
            -- Classify action
            CASE 
                WHEN (boalf.levelTo - boalf.levelFrom) > 0 THEN 'DISCHARGE'
                WHEN (boalf.levelTo - boalf.levelFrom) < 0 THEN 'CHARGE'
                ELSE 'HOLD'
            END as action_type
        FROM `{PROJECT_ID}.{DATASET_ID}.bmrs_boalf` boalf
        LEFT JOIN market_prices prices
            ON boalf.settlementDate = prices.settlementDate
            AND boalf.settlementPeriodFrom = prices.settlementPeriod
        WHERE boalf.settlementDate >= DATE_SUB(CURRENT_DATE(), INTERVAL {ANALYSIS_DAYS} DAY)
          AND ABS(boalf.levelTo - boalf.levelFrom) > 0  -- Only real changes
          AND boalf.bmUnit IN ('{battery_list_sql}')
    )
    SELECT *
    FROM battery_actions
    WHERE avg_price_gbp_mwh IS NOT NULL
    ORDER BY bmUnit, settlementDate, settlementPeriodFrom
    """
    
    print(f"ğŸ” Querying battery acceptance data (last {ANALYSIS_DAYS} days)...")
    print(f"   Targeting first 150 batteries from list...")
    
    df = client.query(query).to_dataframe()
    
    # Merge capacity from CSV  
    df['capacity_mw'] = df['bmUnit'].map(capacity_map).fillna(0)
    
    print(f"âœ… Loaded {len(df):,} acceptance records for {df['bmUnit'].nunique()} batteries")
    
    return df


def calculate_charge_discharge_pairs(df, duration_hours):
    """
    Match charge/discharge pairs and calculate net profit per cycle
    """
    results = []
    
    for bmu in df['bmUnit'].unique():
        bmu_data = df[df['bmUnit'] == bmu].copy()
        bmu_data = bmu_data.sort_values(['settlementDate', 'settlementPeriodFrom'])
        
        capacity_mw = bmu_data['capacity_mw'].iloc[0]
        energy_capacity_mwh = capacity_mw * duration_hours
        
        # Simple cycle counting: alternating charge/discharge
        charges = bmu_data[bmu_data['action_type'] == 'CHARGE'].copy()
        discharges = bmu_data[bmu_data['action_type'] == 'DISCHARGE'].copy()
        
        # Aggregate by settlement period for cleaner matching
        charge_summary = charges.groupby(['settlementDate', 'settlementPeriodFrom']).agg({
            'mw_change': 'sum',  # Total MW charged
            'avg_price_gbp_mwh': 'mean'
        }).reset_index()
        charge_summary.columns = ['settlementDate', 'settlementPeriod', 'charge_mw', 'charge_price']
        
        discharge_summary = discharges.groupby(['settlementDate', 'settlementPeriodFrom']).agg({
            'mw_change': 'sum',  # Total MW discharged
            'avg_price_gbp_mwh': 'mean'
        }).reset_index()
        discharge_summary.columns = ['settlementDate', 'settlementPeriod', 'discharge_mw', 'discharge_price']
        
        # Calculate costs and revenues
        # Each settlement period = 30 minutes = 0.5 hours
        charge_summary['energy_charged_mwh'] = abs(charge_summary['charge_mw']) * 0.5
        charge_summary['charge_cost_gbp'] = charge_summary['energy_charged_mwh'] * charge_summary['charge_price']
        
        discharge_summary['energy_discharged_mwh'] = discharge_summary['discharge_mw'] * 0.5
        discharge_summary['discharge_revenue_gbp'] = discharge_summary['energy_discharged_mwh'] * discharge_summary['discharge_price']
        
        # Apply round-trip efficiency loss to discharge revenue
        discharge_summary['discharge_revenue_net_gbp'] = discharge_summary['discharge_revenue_gbp'] * ROUND_TRIP_EFFICIENCY
        
        # Totals
        total_charge_cost = charge_summary['charge_cost_gbp'].sum()
        total_discharge_revenue = discharge_summary['discharge_revenue_net_gbp'].sum()
        total_energy_charged = charge_summary['energy_charged_mwh'].sum()
        total_energy_discharged = discharge_summary['energy_discharged_mwh'].sum()
        
        # Estimate number of full cycles
        # One cycle = charge energy_capacity_mwh, then discharge energy_capacity_mwh
        cycles_from_charge = total_energy_charged / energy_capacity_mwh if energy_capacity_mwh > 0 else 0
        cycles_from_discharge = total_energy_discharged / energy_capacity_mwh if energy_capacity_mwh > 0 else 0
        estimated_cycles = min(cycles_from_charge, cycles_from_discharge)  # Conservative estimate
        
        # Net profit
        net_profit = total_discharge_revenue - total_charge_cost
        
        # Average prices
        avg_charge_price = charge_summary['charge_price'].mean() if len(charge_summary) > 0 else 0
        avg_discharge_price = discharge_summary['discharge_price'].mean() if len(discharge_summary) > 0 else 0
        avg_spread = avg_discharge_price - avg_charge_price
        
        # Profit per cycle
        profit_per_cycle = net_profit / estimated_cycles if estimated_cycles > 0 else 0
        
        # CAPEX for this duration
        capex_per_kwh = CAPEX_BY_DURATION.get(duration_hours, 200)
        total_capex = energy_capacity_mwh * 1000 * capex_per_kwh  # MWh to kWh
        
        # ROI
        annual_net_profit = net_profit * (365 / ANALYSIS_DAYS)
        roi_pct = (annual_net_profit / total_capex * 100) if total_capex > 0 else 0
        payback_years = total_capex / annual_net_profit if annual_net_profit > 0 else np.inf
        
        # Active days
        active_days = bmu_data['settlementDate'].nunique()
        cycles_per_day = estimated_cycles / active_days if active_days > 0 else 0
        
        results.append({
            'bmUnit': bmu,
            'duration_hours': duration_hours,
            'capacity_mw': capacity_mw,
            'energy_capacity_mwh': energy_capacity_mwh,
            'total_charge_cost_gbp': total_charge_cost,
            'total_discharge_revenue_gbp': total_discharge_revenue,
            'net_profit_gbp': net_profit,
            'estimated_cycles': estimated_cycles,
            'profit_per_cycle_gbp': profit_per_cycle,
            'avg_charge_price_gbp_mwh': avg_charge_price,
            'avg_discharge_price_gbp_mwh': avg_discharge_price,
            'avg_spread_gbp_mwh': avg_spread,
            'round_trip_efficiency': ROUND_TRIP_EFFICIENCY,
            'total_energy_charged_mwh': total_energy_charged,
            'total_energy_discharged_mwh': total_energy_discharged,
            'active_days': active_days,
            'cycles_per_day': cycles_per_day,
            'capex_gbp': total_capex,
            'annual_net_profit_gbp': annual_net_profit,
            'roi_pct': roi_pct,
            'payback_years': payback_years if payback_years != np.inf else 999,
            'charge_actions': len(charge_summary),
            'discharge_actions': len(discharge_summary),
        })
    
    return pd.DataFrame(results)


def analyze_all_durations(df):
    """
    Run analysis for all duration scenarios
    """
    all_results = []
    
    for duration in DURATION_SCENARIOS:
        print(f"\nğŸ“Š Analyzing {duration}h duration scenario...")
        results = calculate_charge_discharge_pairs(df, duration)
        all_results.append(results)
    
    combined = pd.concat(all_results, ignore_index=True)
    return combined


def generate_duration_comparison(df):
    """
    Compare performance across different durations for same batteries
    """
    # Get top 20 batteries by net profit at 2h duration (baseline)
    baseline = df[df['duration_hours'] == 2.0].nlargest(20, 'net_profit_gbp')
    top_bmus = baseline['bmUnit'].unique()
    
    comparison = df[df['bmUnit'].isin(top_bmus)].copy()
    
    # Pivot for easy comparison
    pivot = comparison.pivot_table(
        index='bmUnit',
        columns='duration_hours',
        values=['net_profit_gbp', 'profit_per_cycle_gbp', 'roi_pct', 'cycles_per_day'],
        aggfunc='first'
    )
    
    return pivot, comparison


def print_summary(df):
    """
    Print comprehensive summary of findings
    """
    print("\n" + "="*100)
    print("ğŸ”‹ BATTERY CHARGING COST ANALYSIS - COMPREHENSIVE RESULTS")
    print("="*100)
    
    for duration in sorted(df['duration_hours'].unique()):
        subset = df[df['duration_hours'] == duration].copy()
        subset = subset[subset['net_profit_gbp'] > 0]  # Only profitable batteries
        
        print(f"\n{'â”€'*100}")
        print(f"ğŸ“ˆ DURATION: {duration} HOURS")
        print(f"{'â”€'*100}")
        
        print(f"\nğŸ’° Top 5 Most Profitable (Net Profit After Charging Costs):\n")
        
        top5 = subset.nlargest(5, 'net_profit_gbp')
        
        for idx, row in top5.iterrows():
            print(f"{row['bmUnit']:15s} | "
                  f"Capacity: {row['capacity_mw']:6.1f} MW Ã— {duration}h = {row['energy_capacity_mwh']:7.1f} MWh")
            print(f"                  Charge Cost:    Â£{row['total_charge_cost_gbp']:12,.0f}  "
                  f"@ Â£{row['avg_charge_price_gbp_mwh']:5.1f}/MWh avg")
            print(f"                  Discharge Rev:  Â£{row['total_discharge_revenue_gbp']:12,.0f}  "
                  f"@ Â£{row['avg_discharge_price_gbp_mwh']:5.1f}/MWh avg")
            print(f"                  NET PROFIT:     Â£{row['net_profit_gbp']:12,.0f}  "
                  f"(Spread: Â£{row['avg_spread_gbp_mwh']:5.1f}/MWh)")
            print(f"                  Cycles: {row['estimated_cycles']:6.0f} total "
                  f"({row['cycles_per_day']:4.1f}/day)")
            print(f"                  Profit/Cycle:   Â£{row['profit_per_cycle_gbp']:8,.0f}  "
                  f"| ROI: {row['roi_pct']:5.1f}% | Payback: {row['payback_years']:4.1f}yr")
            print()
        
        print(f"ğŸ“Š Summary Statistics for {duration}h Duration:")
        print(f"   Profitable Batteries:    {len(subset)}")
        print(f"   Total Net Profit:        Â£{subset['net_profit_gbp'].sum():,.0f}")
        print(f"   Avg Profit/Cycle:        Â£{subset['profit_per_cycle_gbp'].mean():,.0f}")
        print(f"   Avg Charge Price:        Â£{subset['avg_charge_price_gbp_mwh'].mean():.1f}/MWh")
        print(f"   Avg Discharge Price:     Â£{subset['avg_discharge_price_gbp_mwh'].mean():.1f}/MWh")
        print(f"   Avg Spread Captured:     Â£{subset['avg_spread_gbp_mwh'].mean():.1f}/MWh")
        print(f"   Avg Cycles/Day:          {subset['cycles_per_day'].mean():.2f}")
        print(f"   Avg ROI:                 {subset['roi_pct'].mean():.1f}%")
        print(f"   Efficiency Applied:      {ROUND_TRIP_EFFICIENCY*100:.0f}%")


def print_duration_comparison(pivot_df, detail_df):
    """
    Print side-by-side comparison across durations
    """
    print("\n" + "="*100)
    print("ğŸ”„ DURATION SENSITIVITY ANALYSIS - TOP 10 BATTERIES")
    print("="*100)
    print("\nComparing: 0.5h, 1h, 1.5h, 2h, 4h durations")
    print("â”€"*100)
    
    # Get top 10 by 2h profit
    baseline = detail_df[detail_df['duration_hours'] == 2.0].nlargest(10, 'net_profit_gbp')
    
    for bmu in baseline['bmUnit'].values:
        bmu_data = detail_df[detail_df['bmUnit'] == bmu].sort_values('duration_hours')
        
        print(f"\nğŸ”‹ {bmu}")
        print(f"   Duration  Capacity   Net Profit  Profit/Cycle  Cycles/Day  ROI     Payback")
        print(f"   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        
        for _, row in bmu_data.iterrows():
            print(f"   {row['duration_hours']:4.1f}h    "
                  f"{row['energy_capacity_mwh']:7.1f} MWh  "
                  f"Â£{row['net_profit_gbp']:9,.0f}   "
                  f"Â£{row['profit_per_cycle_gbp']:7,.0f}     "
                  f"{row['cycles_per_day']:5.2f}     "
                  f"{row['roi_pct']:5.1f}%  "
                  f"{row['payback_years']:5.1f}yr")
        
        # Calculate best duration
        best_duration = bmu_data.loc[bmu_data['net_profit_gbp'].idxmax(), 'duration_hours']
        best_profit = bmu_data['net_profit_gbp'].max()
        print(f"   âœ… Best Duration: {best_duration}h (Â£{best_profit:,.0f} net profit)")


def main():
    """
    Main execution
    """
    print("\n" + "="*100)
    print("ğŸ”‹ BATTERY CHARGING COST ANALYSIS WITH VARIABLE DURATIONS")
    print("="*100)
    print(f"\nâš™ï¸  Configuration:")
    print(f"   Project:              {PROJECT_ID}")
    print(f"   Dataset:              {DATASET_ID}")
    print(f"   Analysis Period:      Last {ANALYSIS_DAYS} days")
    print(f"   Round-trip Efficiency: {ROUND_TRIP_EFFICIENCY*100:.0f}%")
    print(f"   Duration Scenarios:   {', '.join([f'{d}h' for d in DURATION_SCENARIOS])}")
    print(f"   CAPEX Assumptions:    {CAPEX_BY_DURATION}")
    print()
    
    # Load data
    df = get_battery_acceptance_data()
    
    if df.empty:
        print("âŒ No data returned. Check BigQuery access and table names.")
        return
    
    # Analyze all durations
    results = analyze_all_durations(df)
    
    # Print summary
    print_summary(results)
    
    # Duration comparison
    pivot, detail = generate_duration_comparison(results)
    print_duration_comparison(pivot, detail)
    
    # Save results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    output_file = f"battery_charging_cost_analysis_{timestamp}.csv"
    results.to_csv(output_file, index=False)
    print(f"\nğŸ’¾ Saved detailed results: {output_file}")
    
    # Save duration comparison
    comparison_file = f"battery_duration_comparison_{timestamp}.csv"
    detail.to_csv(comparison_file, index=False)
    print(f"ğŸ’¾ Saved duration comparison: {comparison_file}")
    
    print("\n" + "="*100)
    print("âœ… ANALYSIS COMPLETE!")
    print("="*100)
    
    # Key insights
    print("\nğŸ“Š KEY INSIGHTS:\n")
    print("1. CHARGING COSTS MATTER:")
    print("   - Net profit significantly lower than gross revenue")
    print("   - 87% round-trip efficiency means 13% energy loss")
    print("   - Price spread must overcome efficiency losses\n")
    
    print("2. DURATION TRADE-OFFS:")
    print("   - Longer duration = More capacity = Higher max revenue potential")
    print("   - But slower response = May miss rapid price spikes")
    print("   - Shorter duration = More agile = More intraday cycles\n")
    
    print("3. OPTIMAL STRATEGY:")
    print("   - 2h duration appears optimal for UK market (most common)")
    print("   - Balance between capacity and agility")
    print("   - Can cycle 2-3x per day while capturing good spreads\n")
    
    print("4. PROFITABILITY DRIVERS:")
    print("   - Avg spread captured (discharge price - charge price)")
    print("   - Number of cycles per day (utilization)")
    print("   - Round-trip efficiency (minimize losses)")
    print("   - CAPEX per kWh (lower = better ROI)\n")


if __name__ == "__main__":
    main()
